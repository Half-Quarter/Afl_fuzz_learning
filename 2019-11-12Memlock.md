---
layout: post
title: "Memelock"
description: "AFL"
category: 学习技术
tags: [安装与使用]
---
{% include JB/setup %}
##环境准备

解析参数：
-i：输入的路径，路径下存放测试用例
-o：输出的路径
-M：支持并行设置主进程的名称，例如-M fuzzer
-S：支持子进程，例如-S fuzzer1
-f：  testcase的内容会作为afl_test的stdin
-x：？
-t：设置时间，处理一个测试用例的时间不能超过某参数，超过了就给出提醒
-m：设置内存限制，尤其是在开启了asan后，一般在32位下-m 10G？在64位下需要设置为-m 20G以上，或者直接设置为-m none
-d：跳过确定性阶段
-B：load bitmap？
-C：crash mode？开启崩溃探索模式
-n：dumb mode？
-T：banner？
-Q：二进制插桩

在参数解析处多添加了5个参数：

参数解析：
```C
case 'p':
        SAYF("Max count fuzzing...\n");
        max_ct_fuzzing = 1;//类似一个flag吧，用来记录是否开启
        break;
      
      case 's':
        SAYF("Prioritizing less stale inputs...\n");
        prioritize_less_stale = 1;//压力测试？？？
        break;

      case 'c':
        SAYF("Complex staleness...\n");
        complex_stale = 1;
        break; 

     case 'N':
        if (sscanf(optarg, "%llu", &max_file_len) != 1) FATAL("-N argument should be a positive integer");
        break;

      case 'z':
        SAYF("Zeroing all feedback except sum. EXPERIMENTAL\n");
        zero_other_counts = 1;
        break;
```

配置共享内存:多加了PERF_SIZE个来存储无符号的32位数，
```c



/* Configure shared memory and virgin_bits. This is called at startup. */

EXP_ST void setup_shm(void) {

  u8* shm_str;
  u8* mem_str;

  if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);

  memset(virgin_tmout, 255, MAP_SIZE);
  memset(virgin_crash, 255, MAP_SIZE);

  /* in the case of the max count fuzzing, allocate the performance
    map right after the regular bitmap.  */
  /* always allocate so that programs instrumented with afl-clang-fast
     don't cause segfaults */
  shm_id = shmget(IPC_PRIVATE, MAP_SIZE + (PERF_SIZE * sizeof(u32)), IPC_CREAT | IPC_EXCL | 0600);//共享内存1
  shm_sys_data = shmget(IPC_PRIVATE, sizeof(struct sys_data), IPC_CREAT | IPC_EXCL | 0600); //(wcventure)共享内存2用来记录整体的数据

  if (shm_id < 0) PFATAL("shmget() failed");
  if (shm_sys_data < 0) PFATAL("shmget() failed");

  atexit(remove_shm);

  shm_str = alloc_printf("%d", shm_id);
  mem_str = alloc_printf("%d", shm_sys_data);

  /* If somebody is asking us to fuzz instrumented binaries in dumb mode,
     we don't want them to detect instrumentation, since we won't be sending
     fork server commands. This should be replaced with better auto-detection
     later on, perhaps? */

  if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);
  if (!dumb_mode) setenv(MEM_ENV_VAR, mem_str, 1);

  ck_free(shm_str);

  trace_bits = shmat(shm_id, NULL, 0);//用来执行指向了基本块
  mem_data = shmat(shm_sys_data, NULL, 0);//用来指向了整体的一个记录的数据

  // setup perf bits if needes
  if (max_ct_fuzzing) perf_bits = (u32 *) (trace_bits + MAP_SIZE);//perf_bits用来记录了后半部分，这里我认为是记录了函数的调用的次数
  
  if (!trace_bits) PFATAL("shmat() failed");
  if (!mem_data) PFATAL("shmat() failed");

}

```
main添加，在初始化相关的配置以后，添加了依稀下部分：
可以理解为定义了初始化的变量max_counts,用来存储某个函数调用的次数
```C
if (max_ct_fuzzing) setup_max_counts();//------memset(max_counts, 0, PERF_SIZE * sizeof(u32));//初始化max_counts数组大小是2^14
  if (max_ct_fuzzing)
    top_rated= ck_alloc(PERF_SIZE * sizeof(struct queue_entry *));//malloc大小为2^14个的queue_entry大小的内存，用来记录好种子
  else
    top_rated = ck_alloc(MAP_SIZE * sizeof(struct queue_entry *));
```

第一次运行：
```c


/* Perform dry run of all test cases to confirm that the app is working as
   expected. This is done only for the initial inputs, and only once. */

static void perform_dry_run(char** argv) {

  while (q) { 
    res = calibrate_case(argv, q, use_mem, 0, 1);
  
  /* start: dry run中将seed加入top_mem (wcventure) 
    int cksumLocation = -1;
    int insertLocation = -1;
    u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);//这里是对trace_bits做了hash
    if (has_higher_score(cksum, &cksumLocation, &insertLocation) > 0){//如果程序有更高的分数，那就将他加入发到测试用例队列中去，但是此部分作者注释了
      add_to_top_mem(q, cksumLocation, insertLocation); //careful: not queue_top，？？这个做法将测试用例加入到了一个新的队列，这时候程序就有两个队列了。。。？？
    }
     end: dry run中将seed加入top_mem */
    switch (res) {

      case FAULT_NONE:
      if (q == queue) check_map_coverage();
  // Populates the max_counts properly.记录当前测试用例最大的次数
  if (max_ct_fuzzing) has_new_max();//判断是不是有新的最大的值产生

        if (crash_mode) FATAL("Test case '%s' does *NOT* crash", fn);

        break;

      case FAULT_TMOUT:
           ...

      case FAULT_CRASH:  

        

      case FAULT_ERROR:

        FATAL("Unable to execute target application ('%s')", argv[0]);

      case FAULT_NOINST:

        FATAL("No instrumentation detected");

      case FAULT_NOBITS: 

       

        break;

    }

    if (q->var_behavior) WARNF("Instrumentation output varies across runs.");

    q = q->next;

  }

  if (cal_failures) {

    

  }

  OKF("All test cases processed.");

  if (max_ct_fuzzing) {
  DEBUG("======== Starting Keys ========\n");
    for (u32 k=0; k < PERF_SIZE; k++){//打印最大的调用次数？？？在后面运行中可以打印出来
      // if there is a non-zero score at this index.. 
      if (max_counts[k]){
          DEBUG("At key %d, val is %d\n", k, max_counts[k]);
      }
    }
  }

}

```
```c
//矫正测试用例

/* Calibrate a new test case. This is done when processing the input directory
   to warn about flaky or otherwise problematic test cases early on; and when
   new paths are discovered to detect variable behavior and so on. */

static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,
                         u32 handicap, u8 from_queue) {
  // TODO in calibration look at the entire trace bits... booo

  static u8 first_trace[MAP_SIZE];

  u8  fault = 0, new_bits = 0, var_detected = 0,
      first_run = (q->exec_cksum == 0);

  u64 start_us, stop_us;

  s32 old_sc = stage_cur, old_sm = stage_max;
  u32 use_tmout = exec_tmout;
  u8* old_sn = stage_name;

  /* Be a bit more generous about timeouts when resuming sessions, or when
     trying to calibrate already-added finds. This helps avoid trouble due
     to intermittent latency. */

  if (!from_queue || resuming_fuzz)
    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,
                    exec_tmout * CAL_TMOUT_PERC / 100);

  q->cal_failed++;

  stage_name = "calibration";
  stage_max  = fast_cal ? 3 : CAL_CYCLES;

  /* Make sure the forkserver is up before we do anything, and let's not
     count its spin-up time toward binary calibration. */

  if (dumb_mode != 1 && !no_forkserver && !forksrv_pid)
    init_forkserver(argv);

  if (q->exec_cksum) memcpy(first_trace, trace_bits, MAP_SIZE);

  start_us = get_cur_time_us();

  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {

    u32 cksum;

    if (!first_run && !(stage_cur % stats_update_freq)) show_stats();

    write_to_testcase(use_mem, q->len);

    fault = run_target(argv, use_tmout);//运行测试用例，对里面进行了修改

    /* stop_soon is set by the handler for Ctrl+C. When it's pressed,
       we want to bail out quickly. */
    
    ReadMemStatus(&MaxContinueCMNum, &MaxCallNum);//在运行完程序以后进行了读操作，获取当前的运行的调用次数，和总体的调用数量
    stackScore_cur = MaxCallNum;//当前的栈的分数=当前运行的程序的调用次数
    if (stackScore_cur > stackScore_max)//当前的栈分数和之前存储的最大的调用次数比较，超出的话
      stackScore_max = stackScore_cur;//存储栈的最大值

    if (stop_soon || fault != crash_mode) goto abort_calibration;

    if (!dumb_mode && !stage_cur && !count_bytes(trace_bits)) {
      fault = FAULT_NOINST;
      goto abort_calibration;
    }

    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);

    if (q->exec_cksum != cksum) {

      u8 hnb = has_new_bits(virgin_bits);
      if (hnb > new_bits) new_bits = hnb;

      if (q->exec_cksum) {

        u32 i;

        for (i = 0; i < MAP_SIZE; i++) {

          if (!var_bytes[i] && first_trace[i] != trace_bits[i]) {

            var_bytes[i] = 1;
            stage_max    = CAL_CYCLES_LONG;

          }

        }

        var_detected = 1;

      } else {//对于校验相同的情况下，或者说是第一次运行的情况下

        q->exec_cksum = cksum;
        /* setup the perf cksum here. Assume it is not variable, or that 
          variability will be detected in the regular checking */ 
        if (max_ct_fuzzing) 
          q->perf_cksum = hash32(perf_bits, PERF_SIZE*sizeof(u32), HASH_CONST); //这里是对perf_bits进行了hash，这里只是进行了赋值，因为无论运行多少遍测试用例是不变的，也就说他们的次数是不变的，那q->perf_cksum仅仅获得了一个值而已
        memcpy(first_trace, trace_bits, MAP_SIZE);//

      }

    }

  }

  stop_us = get_cur_time_us();

  total_cal_us     += stop_us - start_us;
  total_cal_cycles += stage_max;

  /* OK, let's collect some stats about the performance of this test case.
     This is used for fuzzing air time calculations in calculate_score(). */

  q->exec_us     = (stop_us - start_us) / stage_max;
  q->bitmap_size = count_bytes(trace_bits);
  q->handicap    = handicap;
  q->cal_failed  = 0;

  /* start: CountScore (wcventure) */
  q -> stackScore = stackScore_cur;//测试用例进行打分，打分在前面的run_target()里吧
  /* end: CountScore */

  total_bitmap_size += q->bitmap_size;
  total_bitmap_entries++;

  update_bitmap_score(q);//这里面也进行了改动，原来是在每个分支处找出最小时间*最小长度的种子，现在是在每个分支处找出最大调用次数的种子

  /* If this case didn't result in new output from the instrumentation, tell
     parent. This is a non-critical problem, but something to warn the user
     about. */

  if (!dumb_mode && first_run && !fault && !new_bits) fault = FAULT_NOBITS;

abort_calibration:

  if (new_bits == 2 && !q->has_new_cov) {
    q->has_new_cov = 1;
    queued_with_cov++;
  }

  /* Mark variable paths. */

  if (var_detected) {

    var_byte_count = count_bytes(var_bytes);

    if (!q->var_behavior) {
      mark_as_variable(q);
      queued_variable++;
    }

  }

  stage_name = old_sn;
  stage_cur  = old_sc;
  stage_max  = old_sm;

  if (!first_run) show_stats();

  return fault;

}

```
```c


/* Execute target application, monitoring for timeouts. Return status
   information. The called program will update trace_bits[]. */

static u8 run_target(char** argv, u32 timeout) {

  static struct itimerval it;
  static u32 prev_timed_out = 0;

  int status = 0;
  u32 tb4;

  child_timed_out = 0;

  /* After this memset, trace_bits[] are effectively volatile, so we
     must prevent any earlier operations from venturing into that
     territory. */

  memset(trace_bits, 0, MAP_SIZE);//初始化trace_bit为0
  if (max_ct_fuzzing) memset(perf_bits, 0, PERF_SIZE * sizeof(u32));//对per_bits进行了初始化，也为0，可以理解为程序维护了一个perf_bits，存放当前的测试用例的次数吧
  MEM_BARRIER();

  /* If we're running in "dumb" mode, we can't rely on the fork server
     logic compiled into the target program, so we will just keep calling
     execve(). There is a bit of code duplication between here and 
     init_forkserver(), but c'est la vie. */

  if (dumb_mode == 1 || no_forkserver) {

    child_pid = fork();

    if (child_pid < 0) PFATAL("fork() failed");

    if (!child_pid) {

      struct rlimit r;

      if (mem_limit) {

        r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;

#ifdef RLIMIT_AS

        setrlimit(RLIMIT_AS, &r); /* Ignore errors */

#else

        setrlimit(RLIMIT_DATA, &r); /* Ignore errors */

#endif /* ^RLIMIT_AS */

      }

      r.rlim_max = r.rlim_cur = 0;

      setrlimit(RLIMIT_CORE, &r); /* Ignore errors */

      /* Isolate the process and configure standard descriptors. If out_file is
         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */

      setsid();

      dup2(dev_null_fd, 1);
      dup2(dev_null_fd, 2);

      if (out_file) {

        dup2(dev_null_fd, 0);

      } else {

        dup2(out_fd, 0);
        close(out_fd);

      }

      /* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */

      close(dev_null_fd);
      close(out_dir_fd);
      close(dev_urandom_fd);
      close(fileno(plot_file));

      /* Set sane defaults for ASAN if nothing else specified. */

      setenv("ASAN_OPTIONS", "abort_on_error=1:"
                             "detect_leaks=0:"
                             "symbolize=0:"
                             "allocator_may_return_null=1", 0);

      setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
                             "symbolize=0:"
                             "msan_track_origins=0", 0);

      execv(target_path, argv);

      /* Use a distinctive bitmap value to tell the parent about execv()
         falling through. */

      *(u32*)trace_bits = EXEC_FAIL_SIG;
      exit(0);

    }

  } else {

    s32 res;

    /* In non-dumb mode, we have the fork server up and running, so simply
       tell it to have at it, and then read back PID. */

    if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {

      if (stop_soon) return 0;
      RPFATAL(res, "Unable to request new process from fork server (OOM?)");

    }

    if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4) {

      if (stop_soon) return 0;
      RPFATAL(res, "Unable to request new process from fork server (OOM?)");

    }

    if (child_pid <= 0) FATAL("Fork server is misbehaving (OOM?)");

  }

  /* Configure timeout, as requested by user, then wait for child to terminate. */

  it.it_value.tv_sec = (timeout / 1000);
  it.it_value.tv_usec = (timeout % 1000) * 1000;

  setitimer(ITIMER_REAL, &it, NULL);

  /* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */

  if (dumb_mode == 1 || no_forkserver) {

    if (waitpid(child_pid, &status, 0) <= 0) PFATAL("waitpid() failed");

  } else {

    s32 res;

    if ((res = read(fsrv_st_fd, &status, 4)) != 4) {

      if (stop_soon) return 0;
      RPFATAL(res, "Unable to communicate with fork server (OOM?)");

    }

  }

  if (!WIFSTOPPED(status)) child_pid = 0;

  it.it_value.tv_sec = 0;
  it.it_value.tv_usec = 0;

  setitimer(ITIMER_REAL, &it, NULL);

  total_execs++;

  /* Any subsequent operations on trace_bits must not be moved by the
     compiler below this point. Past this location, trace_bits[] behave
     very normally and do not have to be treated as volatile. */

  MEM_BARRIER();

  tb4 = *(u32*)trace_bits;
  /* this should only bucket the MAP_SIZE part of shmem */
#ifdef __x86_64__
  classify_counts((u64*)trace_bits);
#else
  classify_counts((u32*)trace_bits);
#endif /* ^__x86_64__ */
  if (max_ct_fuzzing && zero_other_counts) {//这里的zero_other_counts在参数解析处进行定义过
    memset(trace_bits + MAP_SIZE + sizeof(u32), 0, sizeof(u32)*(PERF_SIZE -1));//这里的意思述说对sizeof(u32)*(PERF_SIZE -1)置0，那trace_bits到trace_bits + MAP_SIZE + sizeof(u32)之前存储的应该是总的装机次数的和？？
  }

  prev_timed_out = child_timed_out;

  /* Report outcome to caller. */

  if (WIFSIGNALED(status) && !stop_soon) {

    kill_signal = WTERMSIG(status);

    if (child_timed_out && kill_signal == SIGKILL) return FAULT_TMOUT;

    return FAULT_CRASH;

  }

  /* A somewhat nasty hack for MSAN, which doesn't support abort_on_error and
     must use a special exit code. */

  if (uses_asan && WEXITSTATUS(status) == MSAN_ERROR) {
    kill_signal = 0;
    return FAULT_CRASH;
  }

  if ((dumb_mode == 1 || no_forkserver) && tb4 == EXEC_FAIL_SIG)
    return FAULT_ERROR;

  return FAULT_NONE;

}

```
```c
在runtarget后面执行了一下操作
/* start: dry run中将seed加入top_mem (wcventure) 
    int cksumLocation = -1;
    int insertLocation = -1;
    u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
    if (has_higher_score(cksum, &cksumLocation, &insertLocation) > 0){
      add_to_top_mem(q, cksumLocation, insertLocation); //careful: not queue_top
    }
     end: dry run中将seed加入top_mem */
     //校正测试用例部分：在运行完测试用例以后
 ReadMemStatus(&MaxContinueCMNum, &MaxCallNum);//读取内存的状态，这两个参数定义在llvm中，可以理解为在插桩中信息
    stackScore_cur = MaxCallNum;//最大的调用次数，也是在也插桩文件中定义的，然后又去取出来，赋值了stackScore_cur，也就是当前测试用例的的得分，下面附上llvm中的代码
    if (stackScore_cur > stackScore_max)
      stackScore_max = stackScore_cur;//找出调用次数最多的函数
```
涉及到llvm的相关的内容
```C
#include "../config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ipc.h>//ipc
#include <sys/shm.h>
#include <unistd.h>

#ifdef __GNUC__
#define _msize malloc_usable_size
#endif

struct sys_data
{
	unsigned long long int MaxContinueCMNum;
	unsigned long long int MaxCallNum;//最大的调用次数
};

static unsigned long long int MaxCallNum = 0;//最大的调用的次数
static unsigned long long int ContinueCallNum = 1000000; //防溢出，当前最大的调用次数
static unsigned long long int MaxContinueCMNum = 0;//最大的调用

void __attribute__((constructor)) traceBegin(void) {//在main函数前执行
  ;
}

void __attribute__((destructor)) traceEnd(void) {//在main函数后执行

  unsigned char *mem_str = getenv(MEM_ENV_VAR);

  if (mem_str) {

    unsigned int shm_mem_id = atoi(mem_str);

    struct sys_data *da;

    da = shmat(shm_mem_id, NULL, 0);//获取共享内存的指针吧

    /* Whooooops. */

    if (da == (void *)-1) _exit(1);

    /* Write something into the bitmap so that even with low AFL_INST_RATIO,
       our parent doesn't give up on us. */
    if(MaxContinueCMNum < 2000000)//在哪main函数执行后判断MaxContinueCMNum，如果小于2000000那就是200000，这个变量应该是在插桩在在程序里面了
      MaxContinueCMNum = 2000000;
    if(MaxCallNum < 1000000)//最大的调用次数
      MaxCallNum = 1000000;
    da->MaxContinueCMNum = MaxContinueCMNum-2000000;
	  da->MaxCallNum = MaxCallNum-1000000;
  }
}

void instr_Call () {//这是一个追踪的函数，每次调用新的函数的时候都进行分析，获取相关的信息
  ContinueCallNum++;
  if (ContinueCallNum > MaxCallNum)
    MaxCallNum = ContinueCallNum;
  if (ContinueCallNum > MaxContinueCMNum)
    MaxContinueCMNum = ContinueCallNum;
}

void instr_Return () {//这个应该是每次函数返回的时候，获取相关的信息并进行记载
  ContinueCallNum--;//在这里调用的数量会减少ContinueCallNum应该是维护的一条路劲执行的调用的次数？？？
}
```

```c
 q -> stackScore = stackScore_cur;//对测试用来的分数进行赋值，这个分数是在插桩运行后的信息中得到的
```
```c
//对测试用例进行打分
这里的好的测试用例并不是运行时间短且长度短的，而是调用次数多的，后续改进可以改这个。
/* When we bump into a new path, we call this to see if the path appears
   more "favorable" than any of the existing ones. The purpose of the
   "favorables" is to have a minimal set of paths that trigger all the bits
   seen in the bitmap so far, and focus on fuzzing them at the expense of
   the rest.

   The first step of the process is to maintain a list of top_rated[] entries
   for every byte in the bitmap. We win that slot if there is no previous
   contender, or if the contender has a more favorable speed x size factor. 

   In the case of performance fuzzing, we win if we maximize the count at some
   key with a non-zero value.   */

static void update_bitmap_score(struct queue_entry* q) {

  u32 i;

  /* For every byte set in trace(or perf)_bits[], see if there is a previous winner,
     and how it compares to us. */

  if (max_ct_fuzzing){

   /* in the case of max fuzzing, just win if we achieve the max */ 
   for (i = 0; i < PERF_SIZE; i++)

      if (perf_bits[i]) {//这里面记录了该测试用例调用某个函数的次数
         
         if (top_rated[i]) {//如果存在一个好的测试用例，但是这次调用的次数小于最大的调用次数，那还是以前的那个号
           if (perf_bits[i] < max_counts[i]) continue;
         }

         /* Insert ourselves as the new winner. */
         top_rated[i] = q;//如果当前的调用大，那就加入到里面

        /* if we get here, we know that perf_bits[i] == max_counts[i] */
         score_changed = 1;

       }

  } else {

    u64 fav_factor = q->exec_us * q->len;

    for (i = 0; i < MAP_SIZE; i++)

      if (unlikely(trace_bits[i])) {
         
         if (top_rated[i]) {

           /* Faster-executing or smaller test cases are favored. */

           if (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) continue;

           /* Looks like we're going to win. Decrease ref count for the
              previous winner, discard its trace_bits[] if necessary. */

           if (!--top_rated[i]->tc_ref) {
             ck_free(top_rated[i]->trace_mini);
             top_rated[i]->trace_mini = 0;
           }

         }

        /* Insert ourselves as the new winner. */
        top_rated[i] = q;

        /* change scores accordingly */

        q->tc_ref++;

        if (!q->trace_mini) {
          q->trace_mini = ck_alloc(MAP_SIZE >> 3);
          minimize_bits(q->trace_mini, trace_bits);
         }
        score_changed = 1;

       }

  }


}

```
fuzz_one相关的函数：
```c
  /*************
   * STALENESS *陈旧的测试？？
   ************/

  /* Computing staleness */
  if (max_ct_fuzzing && queue_cur->favored && prioritize_less_stale) {//prioritize_less_stale在参数解析处进行了设置

    /* run to populate the perf_bits */
    write_to_testcase(in_buf, queue_cur->len);//将测试用例给目标程序
    run_target(argv, exec_tmout);//运行测试用例
    if (too_stale()) {//如果太陈旧，个人认为这里是因为我们在选择测试用例的时候，好的标准不是运行时间*测试用例的长度了，这样的话那测试用例可能很大，这样的话在性能上有损失，作者为了弥补这个问题，添加了这部分
      munmap(orig_in, queue_cur->len);//取消orig_in指向的内存
      if (in_buf != orig_in) ck_free(in_buf);//这里是将测试用例给free了
      ck_free(out_buf);
      return 1; 
    } 

  }
```
```c
 /*************
   * STALENESS *
   ************/

  /* Computing staleness */
  if (max_ct_fuzzing && queue_cur->favored && prioritize_less_stale) {

    /* run to populate the perf_bits */
    write_to_testcase(in_buf, queue_cur->len);
    run_target(argv, exec_tmout);
    if (too_stale()) {//按照分数返回 0和1当然分数越高返回1的可能性会很小的
      munmap(orig_in, queue_cur->len);
      if (in_buf != orig_in) ck_free(in_buf);
      ck_free(out_buf);
      return 1; 
    } 

  }
//too_stale相当于一个seed section的策略，是在进入mutate阶段之前对seed进行筛选，根据这个seed的perf_bit和max_count的差异来确定是否要跳过这个seed
static u8 too_stale(){

    u8 maxed_by_input[MAP_SIZE];//定义了一个数组
    memset(maxed_by_input, 0, MAP_SIZE);//初始化

    /* minimum staleness achieved by current input */
    u32 my_min_staleness = UINT_MAX;//UINT_MAX is the maximum value for an object of type unsigned int(2^31-1)

    /* overall min/max staleness 总的最小最大的失效*/
    u32 min_staleness = UINT_MAX;//数值越大失效越小？？
    /* start the max at 1 to avoid div by 0 */
    u32 max_staleness = 1;//一开始是1


    /* increment staleness and find my min staleness/overall max staleness */
    for (u32 k=0; k < PERF_SIZE; k++){

      // if there is a non-zero score at this index.. 
      if (max_counts[k]){//当前k处最大的数值

        /* set new overall max or min staleness */
        max_staleness = (max_staleness < staleness[k]) ? staleness[k] : max_staleness;//
        min_staleness = (min_staleness > staleness[k]) ? staleness[k] : min_staleness;

        // TODO WAT
        // log the top rated for this one and the staleness
        if (top_rated[k])//这里面存到额是最好的种子
          DEBUG("There is a top rated at key %d, val is %d, staleness is %d %s\n", k, max_counts[k], staleness[k],
           (perf_bits[k] == max_counts[k]) ? "(maxed by me)" : "");

        /* increment staleness for any score that this input hits the max of.
           If score is increased while fuzzing input, staleness will be set to 0  */
        if (perf_bits[k] == max_counts[k]){//如果当前的测试用例，对对应的k处是最大的调用次数

          my_min_staleness = (staleness[k] < my_min_staleness) ? staleness[k] : my_min_staleness;
          staleness[k]++;//成就次数加1
          maxed_by_input[k] = 1;//表示这个地方的是最大的装机的四数，过时程度多了1

        }
      }
    }

    u32 staleness_score;//定义了一个分数
    if (!complex_stale)//这里也是我们在参数分析的时候加入的flag，加入了有两个判分的标准
      staleness_score = 100 - STALENESS_CONST*(my_min_staleness-min_staleness)/max_staleness;
    else
      staleness_score = 100 - STALENESS_CONST*(exp(-((double) my_min_staleness-min_staleness)/ sqrt(max_staleness)) +1);

    DEBUG("my_min_stale: %d, min_stale: %d, max_stale: %d, score: %d\n", my_min_staleness, min_staleness, max_staleness, staleness_score);

    if (staleness_score < UR(100)){//得分一小于100，也就是是说分数越高，概率越大

      DEBUG("Skipping because too stale (score: %d, min_stale: %d)\n", staleness_score, min_staleness);

      /* decided to skip the input. remove the increments. */
      for (u32 k=0; k < PERF_SIZE; k++){
        if (unlikely(maxed_by_input[k])) {
          staleness[k]--;
        }
      }
     
      /* too stale. return 1 */
      return 1;//返回1
     
     }

    return 0;//
}
```
```c
common_fuzz_stuff中



/* Write a modified test case, run program, process results. Handle
   error conditions, returning 1 if it's time to bail out. This is
   a helper function for fuzz_one(). */

EXP_ST u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) {

  u8 fault;

  if (post_handler) {

    out_buf = post_handler(out_buf, &len);
    if (!out_buf || !len) return 0;

  }

  write_to_testcase(out_buf, len);

  fault = run_target(argv, exec_tmout);

  ReadMemStatus(&MaxContinueCMNum, &MaxCallNum);//记录最大调用次数和最大继续条用次数？
  stackScore_cur = MaxCallNum;
  if (stackScore_cur > stackScore_max)
    stackScore_max = stackScore_cur;

  if (stop_soon) return 1;

  if (fault == FAULT_TMOUT) {

    if (subseq_tmouts++ > TMOUT_LIMIT) {
      cur_skipped_paths++;
      return 1;
    }

  } else subseq_tmouts = 0;

  /* Users can hit us with SIGUSR1 to request the current input
     to be abandoned. */

  if (skip_requested) {

     skip_requested = 0;
     cur_skipped_paths++;
     return 1;

  }

  /* This handles FAULT_ERROR for us: */

  queued_discovered += save_if_interesting(argv, out_buf, len, fault);

  if (!(stage_cur % stats_update_freq) || stage_cur + 1 == stage_max)
    show_stats();

  return 0;

}




```
```c




/* Check if the result of an execve() during routine fuzzing is interesting,
   save or queue the input test case for further analysis if so. Returns 1 if
   entry is saved, 0 otherwise. */

static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {

  u8  *fn = "";
  u8  hnb;
  u8  hnm = 0;
  s32 fd;
  u8  keeping = 0, res;
  u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);//变了以后的，hash

  if (fault == crash_mode) {

    /* Keep only if there are new bits in the map, add to queue for
       future fuzzing, etc. PERF: also keep if there is a new max*/

    hnb = has_new_bits(virgin_bits);//判断是否产生了新的路径
    // are there some subtleties here of when the max should be set? TODO
  if (max_ct_fuzzing) 
    hnm = has_new_max(); //判断是否产生了新的max

    if ((!hnb) && (!max_ct_fuzzing || !hnm)) { //(wcventure)如果他crash并且没有产生新的路径，也没有产生做最大的调用次数
      if (crash_mode) total_crashes++;//崩溃次数+1
      return 0;
    }    
   

#ifndef SIMPLE_FILES

    fn = alloc_printf("%s/queue/id:%06u,%s%s", out_dir, queued_paths,
                      describe_op(hnb), (max_ct_fuzzing && hnm) ? ",+max" : "" );

#else

    fn = alloc_printf("%s/queue/id_%06u", out_dir, queued_paths);

#endif /* ^!SIMPLE_FILES */

    DEBUG("adding %s to queue\n", fn);

  if (queue_cur->exec_cksum == cksum){ // 改变后并没有产生新路径的变化(wcventure)
    
    add_to_queue(fn, len, 0);//将测试用例加到队列中.
  } else {//如果产生了新的路径
    delete_from_queue(cksum);//删除校验和
    add_to_queue(fn, len, 0);//将测试用例添加到队伍中
  }
    

    if (hnb == 2) {//如果产生了新的路径
      queue_top->has_new_cov = 1;
      queued_with_cov++;
    }

    queue_top->exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);
    if (max_ct_fuzzing) //获取测试用例的perf_bits，添加进去
      queue_top->perf_cksum = hash32(perf_bits, PERF_SIZE*sizeof(u32), HASH_CONST); 

    /* Try to calibrate inline; this also calls update_bitmap_score() when
       successful. */

    res = calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0);//对这个测试用例进行校正打分

    if (res == FAULT_ERROR)
      FATAL("Unable to execute target application");

    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
    if (fd < 0) PFATAL("Unable to create '%s'", fn);
    ck_write(fd, mem, len, fn);
    close(fd);

    keeping = 1;
  
  /* start: calibrate_case后将该得分高的seed加入top_mem (wcventure) 
  int cksumLocation = -1;
  int insertLocation = -1;
  u32 hhs = has_higher_score(cksum, &cksumLocation, &insertLocation);
    if (hhs > 0){
      add_to_top_mem(queue_top, cksumLocation, insertLocation);
    }
     end: calibrate_case后将该得分高的seed加入top_mem */

  }

  switch (fault) {

    case FAULT_TMOUT:

      /* Timeouts are not very interesting, but we're still obliged to keep
         a handful of samples. We use the presence of new bits in the
         hang-specific bitmap as a signal of uniqueness. In "dumb" mode, we
         just keep everything. */

      total_tmouts++;

      if (unique_hangs >= KEEP_UNIQUE_HANG) return keeping;

      if (!dumb_mode) {

#ifdef __x86_64__
        simplify_trace((u64*)trace_bits);
#else
        simplify_trace((u32*)trace_bits);
#endif /* ^__x86_64__ */

        if (!has_new_bits(virgin_tmout)) return keeping;

      }

      unique_tmouts++;

      /* Before saving, we make sure that it's a genuine hang by re-running
         the target with a more generous timeout (unless the default timeout
         is already generous). */

      if (exec_tmout < hang_tmout) {

        u8 new_fault;
        write_to_testcase(mem, len);
        new_fault = run_target(argv, hang_tmout);

        ReadMemStatus(&MaxContinueCMNum, &MaxCallNum);
        stackScore_cur = MaxCallNum;
        if (stackScore_cur > stackScore_max)
          stackScore_max = stackScore_cur;

        /* A corner case that one user reported bumping into: increasing the
           timeout actually uncovers a crash. Make sure we don't discard it if
           so. */

        if (!stop_soon && new_fault == FAULT_CRASH) goto keep_as_crash;

        if (stop_soon || new_fault != FAULT_TMOUT) return keeping;

      }

#ifndef SIMPLE_FILES

      fn = alloc_printf("%s/hangs/id:%06llu,%s", out_dir,
                        unique_hangs, describe_op(0));

#else

      fn = alloc_printf("%s/hangs/id_%06llu", out_dir,
                        unique_hangs);

#endif /* ^!SIMPLE_FILES */

      unique_hangs++;

      last_hang_time = get_cur_time();

      break;

    case FAULT_CRASH:

keep_as_crash:

      /* This is handled in a manner roughly similar to timeouts,
         except for slightly different limits and no need to re-run test
         cases. */

      total_crashes++;

      if (unique_crashes >= KEEP_UNIQUE_CRASH) return keeping;

      if (!dumb_mode) {

#ifdef __x86_64__
        simplify_trace((u64*)trace_bits);
#else
        simplify_trace((u32*)trace_bits);
#endif /* ^__x86_64__ */

        if (!has_new_bits(virgin_crash)) return keeping;

      }

      if (!unique_crashes) write_crash_readme();

#ifndef SIMPLE_FILES

      fn = alloc_printf("%s/crashes/id:%06llu,sig:%02u,%s", out_dir,
                        unique_crashes, kill_signal, describe_op(0));

#else

      fn = alloc_printf("%s/crashes/id_%06llu_%02u", out_dir, unique_crashes,
                        kill_signal);

#endif /* ^!SIMPLE_FILES */

      unique_crashes++;

      last_crash_time = get_cur_time();
      last_crash_execs = total_execs;

      break;

    case FAULT_ERROR: FATAL("Unable to execute target application");

    default: return keeping;

  }

  /* If we're here, we apparently want to save the crash or hang
     test case, too. */

  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);
  if (fd < 0) PFATAL("Unable to create '%s'", fn);
  ck_write(fd, mem, len, fn);
  close(fd);

  ck_free(fn);

  return keeping;

}


```
```c
static inline u8 has_new_max() {

  int ret = 0;
  for (int i = 0; i < PERF_SIZE; i++){
      if (unlikely(perf_bits[i])){
        if (unlikely(perf_bits[i] > max_counts[i])) {
           ret = 1;//如果产生的信的最大值，那ret就会设置为1
           DEBUG("New max(0x%04x) = %u (earlier was: %u)\n ", i, perf_bits[i], max_counts[i]);
     max_counts[i] = perf_bits[i];
        }
      }
  }
  
  return ret;

}
```
下面我们就llvm的配置看下，它是如何插桩在程序中进行插桩，如何而fuzz如何获取到相关的内容的。
trace_function_stack.c 这里理解为追踪栈
```c
#include "../config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ipc.h>//ipc
#include <sys/shm.h>
#include <unistd.h>

#ifdef __GNUC__
#define _msize malloc_usable_size
#endif

struct sys_data//定义了一个数据结构
{
  unsigned long long int MaxContinueCMNum;
  unsigned long long int MaxCallNum;
};

static unsigned long long int MaxCallNum = 0;//全局变量用来记录最大的调用的次数，应该是函数在运行了一个测试用例以后的最大的调用的次数
static unsigned long long int ContinueCallNum = 1000000; //防溢出
static unsigned long long int MaxContinueCMNum = 0;

void __attribute__((constructor)) traceBegin(void) {//这里的意思是在main函数之前执行这个
  ;
}

void __attribute__((destructor)) traceEnd(void) {//这里里的意思是在main函数之后执行这个

  unsigned char *mem_str = getenv(MEM_ENV_VAR);

  if (mem_str) {

    unsigned int shm_mem_id = atoi(mem_str);

    struct sys_data *da;

    da = shmat(shm_mem_id, NULL, 0);//获取了共享内存

    /* Whooooops. */

    if (da == (void *)-1) _exit(1);

    /* Write something into the bitmap so that even with low AFL_INST_RATIO,
       our parent doesn't give up on us. */
    if(MaxContinueCMNum < 2000000)
      MaxContinueCMNum = 2000000;
    if(MaxCallNum < 1000000)
      MaxCallNum = 1000000;
    da->MaxContinueCMNum = MaxContinueCMNum-2000000;//在共享内存的MaxContinueCMNum处邪猎了一个值
    da->MaxCallNum = MaxCallNum-1000000;//同理在共享内存的MaxCallNum处写下了另一个值，当前这里的值对应了前面在润 target的读取的部分
  }
}

void instr_Call () {//这里应该是对调用的计算吧，这里也可以理解为程序的插桩？,这里的插桩是在函数调用的时候插桩的
  ContinueCallNum++;
  if (ContinueCallNum > MaxCallNum)
    MaxCallNum = ContinueCallNum;
  if (ContinueCallNum > MaxContinueCMNum)
    MaxContinueCMNum = ContinueCallNum;
}

void instr_Return () {//在返回的时候执行相关的操作
  ContinueCallNum--;
}
```
本模块中定义了persistent mode和trace-pc-guard mode的具体调用，也涉及了初始化forsever的通信，共享内存的操作
```c
/*
   american fuzzy lop - LLVM instrumentation bootstrap
   ---------------------------------------------------

   Written by Laszlo Szekeres <lszekeres@google.com> and
              Michal Zalewski <lcamtuf@google.com>

   LLVM integration design comes from Laszlo Szekeres.

   Copyright 2015, 2016 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   This code is the rewrite of afl-as.h's main_payload.

*/

#include "../config.h"
#include "../types.h"

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#include <sys/mman.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <sys/types.h>

/* This is a somewhat ugly hack for the experimental 'trace-pc-guard' mode.
   Basically, we need to make sure that the forkserver is initialized after
   the LLVM-generated runtime initialization pass, not before. */

#ifdef USE_TRACE_PC
#  define CONST_PRIO 5
#else
#  define CONST_PRIO 0
#endif /* ^USE_TRACE_PC */


/* Globals needed by the injected instrumentation. The __afl_area_initial region
   is used for instrumentation output before __afl_map_shm() has a chance to run.
   It will end up as .comm, so it shouldn't be too wasteful. */

u8  __afl_area_initial[MAP_SIZE];//
u8* __afl_area_ptr = __afl_area_initial;//这里的__afl_area_ptr类似于前面trace_bits,


/* Similarly we have a map for performance counters */
u32  __afl_perf_initial[PERF_SIZE];
u32* __afl_perf_ptr = __afl_perf_initial;//这里面是per_bits的是作者加入的

/* These are saved previous location IDs and strings */
__thread u32 __afl_prev_loc;//这里面是保存的是钱的个地址的ID
__thread u8* __afl_prev_loc_desc;

static FILE* loc_logging_file = NULL;//文件为null


/* Running in persistent mode? */

static u8 is_persistent;


/* SHM setup. */

static void __afl_map_shm(void) {

  u8 *id_str = getenv(SHM_ENV_VAR);

  /* If we're running under AFL, attach to the appropriate region, replacing the
     early-stage __afl_area_initial region that is needed to allow some really
     hacky .init code to work correctly in projects such as OpenSSL. */

  if (id_str) {

    u32 shm_id = atoi(id_str);

    __afl_area_ptr = shmat(shm_id, NULL, 0);

    /* Whooooops. */

    if (__afl_area_ptr == (void *)-1) _exit(1);

    /* Write something into the bitmap so that even with low AFL_INST_RATIO,
       our parent doesn't give up on us. */

    __afl_area_ptr[0] = 1;


    /* Set perf pointer to be just after the trace bits map */
    __afl_perf_ptr = &__afl_area_ptr[MAP_SIZE];

  }

  /* Maybe enable logging */
  char* loc_logging_file_name = getenv("AFL_LOG_LOC");
  if (loc_logging_file_name) {
    loc_logging_file = fopen(loc_logging_file_name, "a");    
  }

}


/* Fork server logic. */

static void __afl_start_forkserver(void) {

  static u8 tmp[4];
  s32 child_pid;

  u8  child_stopped = 0;

  /* Phone home and tell the parent that we're OK. If parent isn't there,
     assume we're not running in forkserver mode and just execute program. */

  if (write(FORKSRV_FD + 1, tmp, 4) != 4) return;//在fuzzer的代码中，他首先是向子程序进行了execve，子程序运行向parent端写4个字节，父进程会读取，那链接建立。

  while (1) {

    u32 was_killed;
    int status;

    /* Wait for parent by reading from the pipe. Abort if read fails. */

    if (read(FORKSRV_FD, &was_killed, 4) != 4) _exit(1);//这里forksever等待parent发命令，读取命令管道

    /* If we stopped the child in persistent mode, but there was a race
       condition and afl-fuzz already issued SIGKILL, write off the old
       process. */

    if (child_stopped && was_killed) {
      child_stopped = 0;
      if (waitpid(child_pid, &status, 0) < 0) _exit(1);
    }

    if (!child_stopped) {

      /* Once woken up, create a clone of our process. */

      child_pid = fork();//一旦forksever接收到fuzzer的信息，调用fork，得到父进程和子进程
      if (child_pid < 0) _exit(1);

      /* In child process: close fds, resume execution. */

      if (!child_pid) {//这里是target app，子进程关闭不需要的管道。跳转到_afl_fork_resume

        close(FORKSRV_FD);
        close(FORKSRV_FD + 1);
        return;
  
      }

    } else {//这里是foksever

      /* Special handling for persistent mode: if the child is alive but
         currently stopped, simply restart it with SIGCONT. */

      kill(child_pid, SIGCONT);
      child_stopped = 0;

    }

    /* In parent process: write PID to pipe, then wait for child. 在父进程中也就是forksever中pid写给fuzzer，然后都等着target运行*/

    if (write(FORKSRV_FD + 1, &child_pid, 4) != 4) _exit(1);

    if (waitpid(child_pid, &status, is_persistent ? WUNTRACED : 0) < 0)
      _exit(1);

    /* In persistent mode, the child stops itself with SIGSTOP to indicate
       a successful run. In this case, we want to wake it up without forking
       again. */

    if (WIFSTOPPED(status)) child_stopped = 1;

    /* Relay wait status to pipe, then loop back. */

    if (write(FORKSRV_FD + 1, &status, 4) != 4) _exit(1);//forksever将target运行后的状态给写给fuzzer

  }

}


/* A simplified persistent mode handler, used as explained in README.llvm. */
//persistent 模式就是在程序的某个代码位置不断喂生成的变异数据 进行 fuzz , 而不用每次喂数据都得重新 fork 一个程序。
int __afl_persistent_loop(unsigned int max_cnt) {

  static u8  first_pass = 1;
  static u32 cycle_cnt;

  if (first_pass) {//第一次运行

    /* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.
       On subsequent calls, the parent will take care of that, but on the first
       iteration, it's our job to erase any trace of whatever happened
       before the loop. */

    if (is_persistent) {//判断是并行的mode

      memset(__afl_area_ptr, 0, MAP_SIZE);//bitmap置0
      memset(__afl_perf_ptr, 0, PERF_SIZE * sizeof(u32));
      __afl_area_ptr[0] = 1;
      __afl_prev_loc = 0;//保存的是前一次跳转的位置
    }

    cycle_cnt  = max_cnt;
    first_pass = 0;//后面的话就不是第一次运行了
    return 1;

  }

  if (is_persistent) {//后面的运行

    if (--cycle_cnt) {//在的代码中会设置运行的次数AFL_LOOP(1000)是代码运行的次数，每次都会进行减小

      raise(SIGSTOP);

      __afl_area_ptr[0] = 1;//每次运行他们的__afl_area_ptr[0]=1,更新的bitmap，而不是将他们重置位0
      __afl_prev_loc = 0;

      return 1;

    } else {

      /* When exiting __AFL_LOOP(), make sure that the subsequent code that
         follows the loop is not traced. We do that by pivoting back to the
         dummy output region. */

      __afl_area_ptr = __afl_area_initial;//没有退出后回归原来

    }

  }

  return 0;

}


/* This one can be called from user code when deferred forkserver mode
    is enabled. */

void __afl_manual_init(void) {

  static u8 init_done;

  if (!init_done) {//如果没有正确初始化的时候

    __afl_map_shm();
    __afl_start_forkserver();
    init_done = 1;

  }

}


/* Proper initialization routine. */

__attribute__((constructor(CONST_PRIO))) void __afl_auto_init(void) {//这个用来追踪循环的次数

  is_persistent = !!getenv(PERSIST_ENV_VAR);

  if (getenv(DEFER_ENV_VAR)) return;

  __afl_manual_init();

}


/* The following stuff deals with supporting -fsanitize-coverage=trace-pc-guard.
   It remains non-operational in the traditional, plugin-backed LLVM mode.
   For more info about 'trace-pc-guard', see README.llvm.

   The first function (__sanitizer_cov_trace_pc_guard) is called back on every
   edge (as opposed to every basic block). */

void __sanitizer_cov_trace_pc_guard(uint32_t* guard) {//每个代码块的尾部都会插入这个函数的代码，并且每个代码块都有独立的guard变量可以操作。此处通过guard变量的值来代表各个代码块的ID，从而使用如下代码来标记目标代码块被执行到，以此作为新路径的判断依据：
  __afl_area_ptr[*guard]++;
}


/* Init callback. Populates instrumentation IDs. Note that we're using
   ID of 0 as a special value to indicate non-instrumented bits. That may
   still touch the bitmap, but in a fairly harmless way. */
/*__sanitizer_cov_trace_pc_guard_init(uint32_t* start, uint32_t* stop)：对guard做了一些初始化的工作，给每个代码块的guard都分配一个随机的ID。如果用户通过AFL_INST_RATIO环境变量来设置了插桩覆盖比例，则根据这个比例的值来对部分代码块的ID标记为0，代表不用插桩。主要逻辑代码如下：*/
void __sanitizer_cov_trace_pc_guard_init(uint32_t* start, uint32_t* stop) {

  u32 inst_ratio = 100;
  u8* x;

  if (start == stop || *start) return;

  x = getenv("AFL_INST_RATIO");
  if (x) inst_ratio = atoi(x);//获取代码插桩的比例

  if (!inst_ratio || inst_ratio > 100) {
    fprintf(stderr, "[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n");
    abort();
  }

  /* Make sure that the first element in the range is always set - we use that
     to avoid duplicate calls (which can happen as an artifact of the underlying
     implementation in LLVM). */

  *(start++) = R(MAP_SIZE - 1) + 1;//设置一个随机数

  while (start < stop) {

    if (R(100) < inst_ratio) *start = R(MAP_SIZE - 1) + 1;
    else *start = 0;//比如果插桩比例70%，有30%的没有插桩的部分这是为0

    start++;

  }

}


/* Optionally log source locations */
void __afl_log_loc(char* prev_loc, char* cur_loc) {
    if (loc_logging_file) {
        fprintf(loc_logging_file, "BRANCH %s-->%s\n", prev_loc, cur_loc);

    }
}

```
afl-llvm-pass.so.cc
该库的主要作用是向LLVM编译中添加AFL所需的Pass模块。

LLVM的Pass
根据本人的理解，LLVM中包含了许多Pass。LLVM每次编译时的一些特殊处理如优化操作，都是由单个或多个Pass一起完成的。因此，可以把Pass认为是用LLVM编译中的一个节点。
所以AFL-LLVM中的所有操作都是通过Pass完成的。
```c
/*该库的主要作用是向LLVM编译中添加AFL所需的Pass模块。

LLVM的Pass
根据本人的理解，LLVM中包含了许多Pass。LLVM每次编译时的一些特殊处理如优化操作，都是由单个或多个Pass一起完成的。因此，可以把Pass认为是用LLVM编译中的一个节点。
所以AFL-LLVM中的所有操作都是通过Pass完成的。
   american fuzzy lop - LLVM-mode instrumentation pass
   ---------------------------------------------------

   Written by Laszlo Szekeres <lszekeres@google.com> and
              Michal Zalewski <lcamtuf@google.com>

   LLVM integration design comes from Laszlo Szekeres. C bits copied-and-pasted
   from afl-as.c are Michal's fault.

   Copyright 2015, 2016 Google Inc. All rights reserved.
   Copyright 2019 wcventure Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   This library is plugged into LLVM when invoking clang through afl-clang-fast.
   It tells the compiler to add code roughly equivalent to the bits discussed
   in ../afl-as.h.

 */

#define AFL_LLVM_PASS

#include "../config.h"
#include "../debug.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "llvm/ADT/Statistic.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Constant.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {

  class AFLCoverage : public ModulePass {//定义了一个AFLCoverage集成了MoudulePass，这个类是以程序作为一个单元进行的分析

    public:

      static char ID;
      AFLCoverage() : ModulePass(ID) { }

      bool runOnModule(Module &M) override;//以模块为单位

      // StringRef getPassName() const override {
      //  return "American Fuzzy Lop Instrumentation";
      // }

  };

}

static inline std::string loc_description (const DebugLoc& dd) {
  if(!dd) { return "?"; }
  auto* scope = cast<DIScope>(dd.getScope());
  return scope->getFilename().str() + ":" + std::to_string(dd.getLine()) + ":" + std::to_string(dd.getCol());
}

static inline std::string bb_description(const BasicBlock& bb) {
  return "(" + loc_description(bb.getInstList().begin()->getDebugLoc()) + "-" + loc_description(bb.getTerminator()->getDebugLoc()) + ")";

}


char AFLCoverage::ID = 0;

//这是在线程上下文中使用LLVM的重要类。它（不透明地）拥有和管理LLVM核心基础结构的核心“全局”数据，包括类型和常量唯一表。 LLVMContext本身不提供锁定保证，因此您应注意每个线程只有一个上下文。
bool AFLCoverage::runOnModule(Module &M) {

  LLVMContext &C = M.getContext();//获取线程的上下文

  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);
  IntegerType *Int32Ty = IntegerType::getInt32Ty(C);
  PointerType *CharPtrTy = PointerType::getUnqual(Int8Ty);
  Type *VoidTy = Type::getVoidTy(C);

  /* Show a banner */

  char be_quiet = 0;

  if (isatty(2) && !getenv("AFL_QUIET")) {

    SAYF(cCYA "Stack-overflow-fuzzer: afl-llvm-pass " cBRI VERSION cRST " by <wcventure@126.com>\n");

  } else be_quiet = 1;

  /* Decide instrumentation ratio */

  char* inst_ratio_str = getenv("AFL_INST_RATIO");//获取插桩的比例
  unsigned int inst_ratio = 100;

  if (inst_ratio_str) {

    if (sscanf(inst_ratio_str, "%u", &inst_ratio) != 1 || !inst_ratio ||
        inst_ratio > 100)
      FATAL("Bad value of AFL_INST_RATIO (must be between 1 and 100)");

  }

  /* Get globals for the SHM region and the previous location. Note that
     __afl_prev_loc is thread-local. */

    /* 添加函数声明，插桩用途 */
  llvm::LLVMContext& context = M.getContext ();
  llvm::IRBuilder<> builder(context); //在context中添加指令
  
  // Function instr_Call()添加追踪函数
  llvm::FunctionType *funcCallType = 
      llvm::FunctionType::get(builder.getVoidTy(), false);
  llvm::Function *instr_CallFunc = //创建一个函数
      llvm::Function::Create(funcCallType, llvm::Function::ExternalLinkage, "instr_Call", &M);

  // Function instr_Return()添加返回的追踪分析函数
  llvm::FunctionType *funcReturnType = 
      llvm::FunctionType::get(builder.getVoidTy(), false);
  llvm::Function *instr_ReturnFunc = 
      llvm::Function::Create(funcReturnType, llvm::Function::ExternalLinkage, "instr_Return", &M);

  GlobalVariable *AFLMapPtr =
      new GlobalVariable(M, PointerType::get(Int8Ty, 0), false,
                         GlobalValue::ExternalLinkage, 0, "__afl_area_ptr");//获取全局变量__afl_area_ptr
  
  GlobalVariable *AFLPerfPtr =
      new GlobalVariable(M, PointerType::get(Int32Ty, 0), false,
                         GlobalValue::ExternalLinkage, 0, "__afl_perf_ptr");

  GlobalVariable *AFLPrevLoc = new GlobalVariable(
      M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_prev_loc",
      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);

  GlobalVariable *AFLPrevLocDesc = new GlobalVariable(
      M, CharPtrTy, false, GlobalValue::ExternalLinkage, 0, "__afl_prev_loc_desc",
      0, GlobalVariable::GeneralDynamicTLSModel, 0, false);

  ConstantInt* PerfMask = ConstantInt::get(Int32Ty, PERF_SIZE-1);//

  Function* LogLocationsFunc = Function::Create(FunctionType::get(VoidTy, 
      ArrayRef<Type*>({CharPtrTy, CharPtrTy}), true), GlobalVariable::ExternalLinkage,
      "__afl_log_loc", &M);
  

  /* Instrument all the things! */

  int inst_blocks = 0;

  for (auto &F : M) {//对函数

    bool functionFlag = true;//第一次进函数时flag为true，插桩后改为false

    for (auto &BB : F) {//对基本块

      BasicBlock::iterator IP = BB.getFirstInsertionPt();//获取基本块的第一条指令
      IRBuilder<> IRB(&(*IP));//指令的位置进行插桩

      if (functionFlag == true){//既是基本块也是函数？？？

        functionFlag = false;

        /* Make up cur_loc */

        unsigned int cur_loc = AFL_R(MAP_SIZE);//随机数

        ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);//当前基本块
        
        /* Get current source location information */
        std::string cur_loc_desc = bb_description(BB);//地址
        Value* CurLocDesc = IRB.CreateGlobalStringPtr(cur_loc_desc);

        /* Load prev_loc */

        LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);//前一个基本块
        PrevLoc->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());

        /* Get edge ID as XOR */
        Value* EdgeId = IRB.CreateXor(PrevLocCasted, CurLoc);//XOR

        /* Load SHM pointer */

        LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);//共享内存的指针
        MapPtr->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *MapPtrIdx =
            IRB.CreateGEP(MapPtr, EdgeId);
        
        LoadInst *PerfPtr = IRB.CreateLoad(AFLPerfPtr);//这部分是作者添加的per_bits的指针
        PerfPtr->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *PerfBranchPtr =
            IRB.CreateGEP(PerfPtr, IRB.CreateAnd(EdgeId, PerfMask));//获取 per_bits[]数数值的下标

        /* Update bitmap */

        LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);
        Counter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));//count+1,增加了撞击的次数
        IRB.CreateStore(Incr, MapPtrIdx)//将数字存进bitmap中
            ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        
        /* Increment performance counter for branch 这个应该是更新单个函数运行的次数*/
        LoadInst *PerfBranchCounter = IRB.CreateLoad(PerfBranchPtr);//数组的下标
        PerfBranchCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *PerfBranchIncr = IRB.CreateAdd(PerfBranchCounter, ConstantInt::get(Int32Ty, 1));
        IRB.CreateStore(PerfBranchIncr, PerfBranchPtr)
            ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        
        /* Increment performance counter for total count 这个应该总的函数运行的次数*/
        LoadInst *PerfTotalCounter = IRB.CreateLoad(PerfPtr); // Index 0 of the perf map
        PerfTotalCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *PerfTotalIncr = IRB.CreateAdd(PerfTotalCounter, ConstantInt::get(Int32Ty, 1));
        IRB.CreateStore(PerfTotalIncr, PerfPtr)
            ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));

        /* Set prev_loc to cur_loc >> 1 */

        StoreInst *Store =
            IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc >> 1), AFLPrevLoc);
        Store->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));

        /* Possibly log location */
        LoadInst* PrevLocDesc = IRB.CreateLoad(AFLPrevLocDesc);
        IRB.CreateCall(LogLocationsFunc, ArrayRef<Value*>({ PrevLocDesc, CurLocDesc }));
        

        /* Set prev_loc_desc to cur_loc_desc */
        IRB.CreateStore(CurLocDesc, AFLPrevLocDesc);

        for(BasicBlock::iterator i = BB.begin(), i2 = BB.end(); i!=i2; i++) {//基本块迭代

          IRBuilder<> MemFuzzBuilder(&(*i)); //插桩的位置

          if(Instruction *inst = dyn_cast<Instruction>(i)) {
            //return函数插桩
            if(inst->getOpcode() == Instruction::Ret)
            {

              /* Update bitmap */

              LoadInst *Counter = MemFuzzBuilder.CreateLoad(MapPtrIdx);
              Counter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *Incr = MemFuzzBuilder.CreateSub(Counter, ConstantInt::get(Int8Ty, 1));
              MemFuzzBuilder.CreateStore(Incr, MapPtrIdx)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              
              /* Decrement performance counter for branch */
              LoadInst *PerfBranchCounter = MemFuzzBuilder.CreateLoad(PerfBranchPtr);
              PerfBranchCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *PerfBranchIncr = MemFuzzBuilder.CreateSub(PerfBranchCounter, ConstantInt::get(Int32Ty, 1));
              MemFuzzBuilder.CreateStore(PerfBranchIncr, PerfBranchPtr)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              
              /* Decrement performance counter for total count  */
              LoadInst *PerfTotalCounter = MemFuzzBuilder.CreateLoad(PerfPtr); // Index 0 of the perf map
              PerfTotalCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *PerfTotalIncr = MemFuzzBuilder.CreateSub(PerfTotalCounter, ConstantInt::get(Int32Ty, 1));
              MemFuzzBuilder.CreateStore(PerfTotalIncr, PerfPtr)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              
              MemFuzzBuilder.CreateCall(instr_ReturnFunc);
            
            }
          }
        }

        IRB.CreateCall(instr_CallFunc);

      } else {

        if (AFL_R(100) >= inst_ratio) continue;

        /* Make up cur_loc */

        unsigned int cur_loc = AFL_R(MAP_SIZE);

        ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);

        /* Load prev_loc */

        LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);
        PrevLoc->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());

        /* Load SHM pointer */

        LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);
        MapPtr->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *MapPtrIdx =
            IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));

        /* Update bitmap */

        LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);
        Counter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
        Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));
        IRB.CreateStore(Incr, MapPtrIdx)
            ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));

        /* Set prev_loc to cur_loc >> 1 */

        StoreInst *Store =
            IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc >> 1), AFLPrevLoc);
        Store->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));

        for(BasicBlock::iterator i = BB.begin(), i2 = BB.end(); i!=i2; i++) {

          IRBuilder<> MemFuzzBuilder(&(*i)); //插桩的位置

          if(Instruction *inst = dyn_cast<Instruction>(i)) {
            //return函数插桩
            if(inst->getOpcode() == Instruction::Ret)
            {

              /* Get current source location information */
              std::string cur_loc_desc = bb_description(BB);
              Value* CurLocDesc = MemFuzzBuilder.CreateGlobalStringPtr(cur_loc_desc);

              /* Get edge ID as XOR */
              Value* EdgeId = MemFuzzBuilder.CreateXor(PrevLocCasted, CurLoc);

              /* Load SHM pointer */
            
              LoadInst *PerfPtr = MemFuzzBuilder.CreateLoad(AFLPerfPtr);
              PerfPtr->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *PerfBranchPtr =
                  MemFuzzBuilder.CreateGEP(PerfPtr, MemFuzzBuilder.CreateAnd(EdgeId, PerfMask));

              /* Update bitmap */

              LoadInst *Counter = MemFuzzBuilder.CreateLoad(MapPtrIdx);
              Counter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *Incr = MemFuzzBuilder.CreateSub(Counter, ConstantInt::get(Int8Ty, 1));
              MemFuzzBuilder.CreateStore(Incr, MapPtrIdx)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              
              /* Increment performance counter for branch */
              LoadInst *PerfBranchCounter = MemFuzzBuilder.CreateLoad(PerfBranchPtr);
              PerfBranchCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *PerfBranchIncr = MemFuzzBuilder.CreateSub(PerfBranchCounter, ConstantInt::get(Int32Ty, 1));
              MemFuzzBuilder.CreateStore(PerfBranchIncr, PerfBranchPtr)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              
              /* Increment performance counter for total count  */
              LoadInst *PerfTotalCounter = MemFuzzBuilder.CreateLoad(PerfPtr); // Index 0 of the perf map
              PerfTotalCounter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
              Value *PerfTotalIncr = MemFuzzBuilder.CreateSub(PerfTotalCounter, ConstantInt::get(Int32Ty, 1));
              MemFuzzBuilder.CreateStore(PerfTotalIncr, PerfPtr)
                  ->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));

              /* Possibly log location */
              LoadInst* PrevLocDesc = MemFuzzBuilder.CreateLoad(AFLPrevLocDesc);
              MemFuzzBuilder.CreateCall(LogLocationsFunc, ArrayRef<Value*>({ PrevLocDesc, CurLocDesc }));

              /* Set prev_loc_desc to cur_loc_desc */
              MemFuzzBuilder.CreateStore(CurLocDesc, AFLPrevLocDesc);

              MemFuzzBuilder.CreateCall(instr_ReturnFunc);

            }
          }
        }

      }

      inst_blocks++;

    }

  }

  /* Say something nice. */

  if (!be_quiet) {

    if (!inst_blocks) WARNF("No instrumentation targets found.");
    else OKF("Instrumented %u locations (%s mode, ratio %u%%).",
             inst_blocks, getenv("AFL_HARDEN") ? "hardened" :
             ((getenv("AFL_USE_ASAN") || getenv("AFL_USE_MSAN")) ?
              "ASAN/MSAN" : "non-hardened"), inst_ratio);

  }

  return true;

}


static void registerAFLPass(const PassManagerBuilder &,
                            legacy::PassManagerBase &PM) {

  PM.add(new AFLCoverage());

}


static RegisterStandardPasses RegisterAFLPass(
    PassManagerBuilder::EP_OptimizerLast, registerAFLPass);

static RegisterStandardPasses RegisterAFLPass0(
    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass);

```
```c
/*
   american fuzzy lop - LLVM-mode wrapper for clang
   ------------------------------------------------

   Written by Laszlo Szekeres <lszekeres@google.com>,
              Michal Zalewski <lcamtuf@google.com> and
        wcventure <wcventure@126.com>

   LLVM integration design comes from Laszlo Szekeres.

   Copyright 2015, 2016 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   This program is a drop-in replacement for clang, similar in most respects
   to ../afl-gcc. It tries to figure out compilation mode, adds a bunch
   of flags, and then calls the real compiler.

 */

#define AFL_MAIN

#include "../config.h"
#include "../types.h"
#include "../debug.h"
#include "../alloc-inl.h"

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

static u8*  obj_path;               /* Path to runtime libraries         */
static u8** cc_params;              /* Parameters passed to the real CC  */
static u32  cc_par_cnt = 1;         /* Param count, including argv0      */


/* Try to find the runtime libraries. If that fails, abort. */

static void find_obj(u8* argv0) {

  u8 *afl_path = getenv("AFL_PATH");
  u8 *slash, *tmp;

  if (afl_path) {

    tmp = alloc_printf("%s/afl-llvm-rt-stack.o", afl_path);

    if (!access(tmp, R_OK)) {
      obj_path = afl_path;
      ck_free(tmp);
      return;
    }

    ck_free(tmp);

  }

  slash = strrchr(argv0, '/');

  if (slash) {

    u8 *dir;

    *slash = 0;
    dir = ck_strdup(argv0);
    *slash = '/';

    tmp = alloc_printf("%s/afl-llvm-rt-stack.o", dir);

    if (!access(tmp, R_OK)) {
      obj_path = dir;
      ck_free(tmp);
      return;
    }

    ck_free(tmp);
    ck_free(dir);

  }

  if (!access(AFL_PATH "/afl-llvm-rt-stack.o", R_OK)) {
    obj_path = AFL_PATH;
    return;
  }

  FATAL("Unable to find 'afl-llvm-rt-stack.o' or 'afl-llvm-pass-stack.so'. Please set AFL_PATH");
 
}


/* Copy argv to cc_params, making the necessary edits. */

static void edit_params(u32 argc, char** argv) {

  u8 fortify_set = 0, asan_set = 0, x_set = 0, maybe_linking = 1, bit_mode = 0;
  u8 *name;

  cc_params = ck_alloc((argc + 128) * sizeof(u8*));

  name = strrchr(argv[0], '/');
  if (!name) name = argv[0]; else name++;

  if (!strcmp(name, "afl-clang-fast++")) {
    u8* alt_cxx = getenv("AFL_CXX");
    cc_params[0] = alt_cxx ? alt_cxx : (u8*)"clang++";
  } else {
    u8* alt_cc = getenv("AFL_CC");
    cc_params[0] = alt_cc ? alt_cc : (u8*)"clang";
  }

  /* There are two ways to compile afl-clang-fast. In the traditional mode, we
     use afl-llvm-pass-stack.so to inject instrumentation. In the experimental
     'trace-pc-guard' mode, we use native LLVM instrumentation callbacks
     instead. The latter is a very recent addition - see:

     http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards */

#ifdef USE_TRACE_PC
  cc_params[cc_par_cnt++] = "-fsanitize-coverage=trace-pc-guard";
  cc_params[cc_par_cnt++] = "-mllvm";
  cc_params[cc_par_cnt++] = "-sanitizer-coverage-block-threshold=0";
#else
  cc_params[cc_par_cnt++] = "-Xclang";
  cc_params[cc_par_cnt++] = "-load";
  cc_params[cc_par_cnt++] = "-Xclang";
  cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-pass-stack.so", obj_path);
#endif /* ^USE_TRACE_PC */

  cc_params[cc_par_cnt++] = "-Qunused-arguments";
  cc_params[cc_par_cnt++] = alloc_printf("%s/trace_function_stack.o", obj_path);

  /* Detect stray -v calls from ./configure scripts. */

  if (argc == 1 && !strcmp(argv[1], "-v")) maybe_linking = 0;

  while (--argc) {
    u8* cur = *(++argv);

    if (!strcmp(cur, "-m32")) bit_mode = 32;
    if (!strcmp(cur, "-m64")) bit_mode = 64;

    if (!strcmp(cur, "-x")) x_set = 1;

    if (!strcmp(cur, "-c") || !strcmp(cur, "-S") || !strcmp(cur, "-E"))
      maybe_linking = 0;

    if (!strcmp(cur, "-fsanitize=address") ||
        !strcmp(cur, "-fsanitize=memory")) asan_set = 1;

    if (strstr(cur, "FORTIFY_SOURCE")) fortify_set = 1;

    if (!strcmp(cur, "-shared")) maybe_linking = 0;

    if (!strcmp(cur, "-Wl,-z,defs") ||
        !strcmp(cur, "-Wl,--no-undefined")) continue;

    cc_params[cc_par_cnt++] = cur;

  }

  if (getenv("AFL_HARDEN")) {

    cc_params[cc_par_cnt++] = "-fstack-protector-all";

    if (!fortify_set)
      cc_params[cc_par_cnt++] = "-D_FORTIFY_SOURCE=2";

  }

  if (!asan_set) {

    if (getenv("AFL_USE_ASAN")) {

      if (getenv("AFL_USE_MSAN"))
        FATAL("ASAN and MSAN are mutually exclusive");

      if (getenv("AFL_HARDEN"))
        FATAL("ASAN and AFL_HARDEN are mutually exclusive");

      cc_params[cc_par_cnt++] = "-U_FORTIFY_SOURCE";
      cc_params[cc_par_cnt++] = "-fsanitize=address";

    } else if (getenv("AFL_USE_MSAN")) {

      if (getenv("AFL_USE_ASAN"))
        FATAL("ASAN and MSAN are mutually exclusive");

      if (getenv("AFL_HARDEN"))
        FATAL("MSAN and AFL_HARDEN are mutually exclusive");

      cc_params[cc_par_cnt++] = "-U_FORTIFY_SOURCE";
      cc_params[cc_par_cnt++] = "-fsanitize=memory";

    }

  }

#ifdef USE_TRACE_PC

  if (getenv("AFL_INST_RATIO"))
    FATAL("AFL_INST_RATIO not available at compile time with 'trace-pc'.");

#endif /* USE_TRACE_PC */

  if (!getenv("AFL_DONT_OPTIMIZE")) {

    cc_params[cc_par_cnt++] = "-g";
    //cc_params[cc_par_cnt++] = "-O3";
    cc_params[cc_par_cnt++] = "-funroll-loops";

  }

  if (getenv("AFL_NO_BUILTIN")) {

    cc_params[cc_par_cnt++] = "-fno-builtin-strcmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strncmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strcasecmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-strncasecmp";
    cc_params[cc_par_cnt++] = "-fno-builtin-memcmp";

  }

  cc_params[cc_par_cnt++] = "-D__AFL_HAVE_MANUAL_CONTROL=1";
  cc_params[cc_par_cnt++] = "-D__AFL_COMPILER=1";
  cc_params[cc_par_cnt++] = "-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1";

  /* When the user tries to use persistent or deferred forkserver modes by
     appending a single line to the program, we want to reliably inject a
     signature into the binary (to be picked up by afl-fuzz) and we want
     to call a function from the runtime .o file. This is unnecessarily
     painful for three reasons:

     1) We need to convince the compiler not to optimize out the signature.
        This is done with __attribute__((used)).

     2) We need to convince the linker, when called with -Wl,--gc-sections,
        not to do the same. This is done by forcing an assignment to a
        'volatile' pointer.

     3) We need to declare __afl_persistent_loop() in the global namespace,
        but doing this within a method in a class is hard - :: and extern "C"
        are forbidden and __attribute__((alias(...))) doesn't work. Hence the
        __asm__ aliasing trick.

   */

  cc_params[cc_par_cnt++] = "-D__AFL_LOOP(_A)="
    "({ static volatile char *_B __attribute__((used)); "
    " _B = (char*)\"" PERSIST_SIG "\"; "
#ifdef __APPLE__
    "__attribute__((visibility(\"default\"))) "
    "int _L(unsigned int) __asm__(\"___afl_persistent_loop\"); "
#else
    "__attribute__((visibility(\"default\"))) "
    "int _L(unsigned int) __asm__(\"__afl_persistent_loop\"); "
#endif /* ^__APPLE__ */
    "_L(_A); })";

  cc_params[cc_par_cnt++] = "-D__AFL_INIT()="
    "do { static volatile char *_A __attribute__((used)); "
    " _A = (char*)\"" DEFER_SIG "\"; "
#ifdef __APPLE__
    "__attribute__((visibility(\"default\"))) "
    "void _I(void) __asm__(\"___afl_manual_init\"); "
#else
    "__attribute__((visibility(\"default\"))) "
    "void _I(void) __asm__(\"__afl_manual_init\"); "
#endif /* ^__APPLE__ */
    "_I(); } while (0)";

  if (maybe_linking) {

    if (x_set) {
      cc_params[cc_par_cnt++] = "-x";
      cc_params[cc_par_cnt++] = "none";
    }

    switch (bit_mode) {

      case 0:
        cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-rt-stack.o", obj_path);
        break;

      case 32:
        cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-rt-stack-32.o", obj_path);

        if (access(cc_params[cc_par_cnt - 1], R_OK))
          FATAL("-m32 is not supported by your compiler");

        break;

      case 64:
        cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-rt-stack-64.o", obj_path);

        if (access(cc_params[cc_par_cnt - 1], R_OK))
          FATAL("-m64 is not supported by your compiler");

        break;

    }

  }

  cc_params[cc_par_cnt] = NULL;

}


/* Main entry point */

int main(int argc, char** argv) {

  if (isatty(2) && !getenv("AFL_QUIET")) {

#ifdef USE_TRACE_PC
    SAYF(cCYA "Stack-overflow-fuzzer: afl-clang-fast [tpcg] " cBRI VERSION  cRST " by <wcventure@126.com>\n");
#else
    SAYF(cCYA "Stack-overflow-fuzzer: afl-clang-fast " cBRI VERSION  cRST " by <wcventure@126.com>\n");
#endif /* ^USE_TRACE_PC */

  }

  if (argc < 2) {

    SAYF("\n"
         "This is a helper application for afl-fuzz. It serves as a drop-in replacement\n"
         "for clang, letting you recompile third-party code with the required runtime\n"
         "instrumentation. A common use pattern would be one of the following:\n\n"

         "  CC=%s/afl-clang-fast ./configure\n"
         "  CXX=%s/afl-clang-fast++ ./configure\n\n"

         "In contrast to the traditional afl-clang tool, this version is implemented as\n"
         "an LLVM pass and tends to offer improved performance with slow programs.\n\n"

         "You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n"
         "AFL_HARDEN enables hardening optimizations in the compiled code.\n\n",
         BIN_PATH, BIN_PATH);

    exit(1);

  }


  find_obj(argv[0]);

  edit_params(argc, argv);

  setenv("LD_PRELOAD", alloc_printf("%s/afl-catch-dlclose.so", obj_path), 1);

  execvp(cc_params[0], (char**)cc_params);

  FATAL("Oops, failed to execute '%s' - check your PATH", cc_params[0]);

  return 0;

}

```
https://www.secpulse.com/archives/71903.html
peseimeng

https://galaxylab.com.cn/afl%E6%A1%86%E6%9E%B6llvm%E6%A8%A1%E5%BC%8F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/